From 9cfc9d6a56b3c6be5c76dbd5bcd95431636ae330 Mon Sep 17 00:00:00 2001
From: Brian Armstrong <brian.armstrong@discordapp.com>
Date: Mon, 27 Mar 2017 19:34:56 -0700
Subject: [PATCH] export exif orientation

this patch changes opencv to do a few things

* create a public api where callers can get ImageDecoders and go through
 the decoding process "manually", which allows them to check for image
 properties before decoding
* add in-memory exif-based rotation (presently opencv only supports this
 for jpegs in files)
* export in-memory rotations
---
 modules/imgcodecs/include/opencv2/imgcodecs.hpp | 151 ++++++++++++++++++++++++
 modules/imgcodecs/src/exif.cpp                  |  45 +++----
 modules/imgcodecs/src/exif.hpp                  |  28 +----
 modules/imgcodecs/src/grfmt_base.cpp            |  28 ++++-
 modules/imgcodecs/src/grfmt_base.hpp            |  24 ++--
 modules/imgcodecs/src/grfmt_bmp.cpp             |  12 +-
 modules/imgcodecs/src/grfmt_bmp.hpp             |   4 +-
 modules/imgcodecs/src/grfmt_exr.cpp             |  13 +-
 modules/imgcodecs/src/grfmt_exr.hpp             |   4 +-
 modules/imgcodecs/src/grfmt_gdal.cpp            |   3 +-
 modules/imgcodecs/src/grfmt_gdal.hpp            |   2 +-
 modules/imgcodecs/src/grfmt_gdcm.cpp            |   5 +-
 modules/imgcodecs/src/grfmt_gdcm.hpp            |   2 +-
 modules/imgcodecs/src/grfmt_hdr.cpp             |   5 +-
 modules/imgcodecs/src/grfmt_hdr.hpp             |   6 +-
 modules/imgcodecs/src/grfmt_jpeg.cpp            |  85 ++++++++++++-
 modules/imgcodecs/src/grfmt_jpeg.hpp            |   7 +-
 modules/imgcodecs/src/grfmt_jpeg2000.cpp        |  13 +-
 modules/imgcodecs/src/grfmt_jpeg2000.hpp        |   4 +-
 modules/imgcodecs/src/grfmt_pam.cpp             |  11 +-
 modules/imgcodecs/src/grfmt_pam.hpp             |   6 +-
 modules/imgcodecs/src/grfmt_png.cpp             |  19 ++-
 modules/imgcodecs/src/grfmt_png.hpp             |   4 +-
 modules/imgcodecs/src/grfmt_pxm.cpp             |  12 +-
 modules/imgcodecs/src/grfmt_pxm.hpp             |   4 +-
 modules/imgcodecs/src/grfmt_sunras.cpp          |  12 +-
 modules/imgcodecs/src/grfmt_sunras.hpp          |   4 +-
 modules/imgcodecs/src/grfmt_tiff.cpp            |  12 +-
 modules/imgcodecs/src/grfmt_tiff.hpp            |   4 +-
 modules/imgcodecs/src/grfmt_webp.cpp            |   5 +-
 modules/imgcodecs/src/grfmt_webp.hpp            |   4 +-
 modules/imgcodecs/src/loadsave.cpp              |  79 ++++++-------
 32 files changed, 454 insertions(+), 163 deletions(-)

diff --git a/modules/imgcodecs/include/opencv2/imgcodecs.hpp b/modules/imgcodecs/include/opencv2/imgcodecs.hpp
index 79805b2..fc9d843 100644
--- a/modules/imgcodecs/include/opencv2/imgcodecs.hpp
+++ b/modules/imgcodecs/include/opencv2/imgcodecs.hpp
@@ -119,6 +119,157 @@ enum ImwritePAMFlags {
        IMWRITE_PAM_FORMAT_RGB_ALPHA = 5,
      };
 
+/**
+ * @brief Picture orientation which may be taken from EXIF
+ *      Orientation usually matters when the picture is taken by
+ *      smartphone or other camera with orientation sensor support
+ *      Corresponds to EXIF 2.3 Specification
+ */
+enum ImageOrientation
+{
+    IMAGE_ORIENTATION_TL = 1, ///< Horizontal (normal)
+    IMAGE_ORIENTATION_TR = 2, ///< Mirrored horizontal
+    IMAGE_ORIENTATION_BR = 3, ///< Rotate 180
+    IMAGE_ORIENTATION_BL = 4, ///< Mirrored vertical
+    IMAGE_ORIENTATION_LT = 5, ///< Mirrored horizontal & rotate 270 CW
+    IMAGE_ORIENTATION_RT = 6, ///< Rotate 90 CW
+    IMAGE_ORIENTATION_RB = 7, ///< Mirrored horizontal & rotate 90 CW
+    IMAGE_ORIENTATION_LB = 8  ///< Rotate 270 CW
+};
+
+/** @brief Decodes an image so that it can be rendered as pixels
+ *
+ * This class should not be constructed directly. Instead, use
+ * one of the findDecoder methods to create a new decoder.
+ *
+ * Once created, the decoder should have setSource called
+ * with the source of the image.
+ *
+ * Next, call readHeader() to load the image metadata. This
+ * populates the height/width/type fields.
+ *
+ * Finally, use readData() to decode the image into a
+ * Mat where the pixels should be stored
+ */
+class CV_EXPORTS_W ImageDecoder
+{
+public:
+    CV_WRAP virtual ~ImageDecoder();
+
+    /** Get image width. Only returns successfully after readHeader() has been called.
+     */
+    CV_WRAP virtual int width() const = 0;
+
+    /** Get image height. Only returns successfully after readHeader() has been called.
+     */
+    CV_WRAP virtual int height() const = 0;
+
+    /** Get image pixel data type. Only returns successfully after readHeader() has been called.
+     */
+    CV_WRAP virtual int type() const = 0;
+
+    /** Get the image's orientation, as set by its metadata, if any
+     */
+    CV_WRAP virtual int orientation() const = 0;
+
+    /** Set decoder to decode file with filename. Returns true on success
+     */
+    CV_WRAP virtual bool setSource( const String& filename ) = 0;
+
+    /** Set decoder to decode image encoded in memory buffer. Returns true on success
+     */
+    CV_WRAP virtual bool setSource( const Mat& buf ) = 0;
+
+    CV_WRAP virtual int setScale( const int& scale_denom ) = 0;
+
+    /** Read the image metadata from the source set by setSource.
+     * Call after setSource has been called
+     * Sets decoder width, height, type
+     * Returns true on success
+     */
+    CV_WRAP virtual bool readHeader() = 0;
+
+    /** Read the image data from the source set by setSource.
+     * Loads deserialized pixels into img, which should be large enough
+     * to store entire image.
+     * Returns true on success
+     */
+    CV_WRAP virtual bool readData( Mat& img ) = 0;
+
+    /// Called after readData to advance to the next page, if any.
+    CV_WRAP virtual bool nextPage() = 0;
+
+    CV_WRAP virtual size_t signatureLength() const = 0;
+    CV_WRAP virtual bool checkSignature( const String& signature ) const = 0;
+
+    CV_WRAP virtual String getDescription() const = 0;
+};
+
+/** @brief Encodes pixels into an image format
+ *
+ * This class should not be constructed directly. Instead, use
+ * findEncoder to construct an Encoder for a particular type of image.
+ */
+class CV_EXPORTS_W ImageEncoder
+{
+public:
+    CV_WRAP virtual ~ImageEncoder();
+
+    CV_WRAP virtual bool isFormatSupported( int depth ) const = 0;
+
+    /** Set the output destination for the serialized image data to a file
+     * with name given by filename
+     */
+    CV_WRAP virtual bool setDestination( const String& filename ) = 0;
+
+    /** Set the output destination for the serialized image data to a memory
+     * buffer given by buf
+     */
+    CV_WRAP virtual bool setDestination( std::vector<uchar>& buf ) = 0;
+
+    /** Write the pixels contained by img into the destination.
+     * setDestination() should be called before calling write
+     * params accepts the same params as imwrite
+     */
+    CV_WRAP virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
+
+    CV_WRAP virtual String getDescription() const = 0;
+
+    CV_WRAP virtual void throwOnEror() const = 0;
+};
+
+
+/** @brief Create an ImageDecoder that can decode the contents pointed at by filename
+ * @param[in] filename File to search
+ *
+ * This method *does not* inspect the extension of the filename, only the contents
+ * in the file itself. So if image.jpg actually contains PNG data, then the
+ * appropriate PNG decoder will be returned when findDecoder("image.jpg") is called.
+ *
+ * @return Image decoder to parse image file.
+*/
+CV_EXPORTS_W Ptr<ImageDecoder> findDecoder( const String& filename );
+
+/** @brief Create an ImageDecoder that can decode the encoded contents of buf
+ * @param[in] buf vector of encoded bytes
+ *
+ * @return Image decoder to parse image file.
+*/
+CV_EXPORTS_W Ptr<ImageDecoder> findDecoder( const Mat& buf );
+
+/** @brief Create an ImageEncoder that can encode pixels into a specific format
+ * @param[in] _ext hint for encoder type
+ *
+ * @return Image encoder to encoder image file.
+*/
+CV_EXPORTS_W Ptr<ImageEncoder> findEncoder( const String& _ext );
+
+/** @brief Applies the orientation transform specified by orientation
+ * @param[in] orientation a valid orientation value
+ * @param[in] img a Mat containing an image to orient
+*/
+CV_EXPORTS_W void OrientationTransform(int orientation, Mat& img);
+
 /** @brief Loads an image from a file.
 
 @anchor imread
diff --git a/modules/imgcodecs/src/exif.cpp b/modules/imgcodecs/src/exif.cpp
index 8a4f3f4..d576e95 100644
--- a/modules/imgcodecs/src/exif.cpp
+++ b/modules/imgcodecs/src/exif.cpp
@@ -61,7 +61,7 @@ ExifEntry_t::ExifEntry_t() :
 /**
  * @brief ExifReader constructor
  */
-ExifReader::ExifReader(std::string filename) : m_filename(filename), m_format(NONE)
+ExifReader::ExifReader(std::istream& stream) : m_stream(stream), m_format(NONE)
 {
 }
 
@@ -128,22 +128,11 @@ std::map<int, ExifEntry_t > ExifReader::getExif()
 
     size_t count;
 
-    if (m_filename.size() == 0)
-    {
-        return m_exif;
-    }
-
-    FILE* f = fopen( m_filename.c_str(), "rb" );
-
-    if( !f )
-    {
-        return m_exif; //Until this moment the map is empty
-    }
-
     bool exifFound = false, stopSearch = false;
-    while( ( !feof( f ) ) && !exifFound && !stopSearch )
+    while( ( !m_stream.eof() ) && !exifFound && !stopSearch )
     {
-        count = fread( appMarker, sizeof(unsigned char), markerSize, f );
+        m_stream.read( reinterpret_cast<char*>(appMarker), markerSize );
+        count = m_stream.gcount();
         if( count < markerSize )
         {
             break;
@@ -159,12 +148,14 @@ std::map<int, ExifEntry_t > ExifReader::getExif()
             case APP0: case APP2: case APP3: case APP4: case APP5: case APP6: case APP7: case APP8:
             case APP9: case APP10: case APP11: case APP12: case APP13: case APP14: case APP15:
             case COM:
-                bytesToSkip = getFieldSize( f );
+                bytesToSkip = getFieldSize();
                 if (bytesToSkip < markerSize) {
-                    fclose(f);
                     throw ExifParsingError();
                 }
-                fseek( f, static_cast<long>( bytesToSkip - markerSize ), SEEK_CUR );
+                m_stream.seekg( static_cast<long>( bytesToSkip - markerSize ), m_stream.cur );
+                if( m_stream.fail() ) {
+                    throw ExifParsingError();
+                }
                 break;
 
             //SOI and EOI don't have the size field after the marker
@@ -172,14 +163,17 @@ std::map<int, ExifEntry_t > ExifReader::getExif()
                 break;
 
             case APP1: //actual Exif Marker
-                exifSize = getFieldSize(f);
+                exifSize = getFieldSize();
                 if (exifSize <= offsetToTiffHeader) {
-                    fclose(f);
                     throw ExifParsingError();
                 }
                 m_data.resize( exifSize - offsetToTiffHeader );
-                fseek(f, static_cast<long>( offsetToTiffHeader ), SEEK_CUR);
-                count = fread( &m_data[0], sizeof( unsigned char ), exifSize - offsetToTiffHeader, f );
+                m_stream.seekg( static_cast<long>( offsetToTiffHeader ), m_stream.cur );
+                if( m_stream.fail() ) {
+                    throw ExifParsingError();
+                }
+                m_stream.read( reinterpret_cast<char*>(&m_data[0]), exifSize - offsetToTiffHeader );
+                count = m_stream.gcount();
                 exifFound = true;
                 break;
 
@@ -189,8 +183,6 @@ std::map<int, ExifEntry_t > ExifReader::getExif()
         }
     }
 
-    fclose(f);
-
     if( !exifFound )
     {
         return m_exif;
@@ -207,10 +199,11 @@ std::map<int, ExifEntry_t > ExifReader::getExif()
  *
  *  @return size of exif field in the file
  */
-size_t ExifReader::getFieldSize (FILE* f) const
+size_t ExifReader::getFieldSize ()
 {
     unsigned char fieldSize[2];
-    size_t count = fread ( fieldSize, sizeof( char ), 2, f );
+    m_stream.read( reinterpret_cast<char*>(fieldSize), 2 );
+    size_t count = m_stream.gcount();
     if (count < 2)
     {
         return 0;
diff --git a/modules/imgcodecs/src/exif.hpp b/modules/imgcodecs/src/exif.hpp
index 43c2857..b1304f9 100644
--- a/modules/imgcodecs/src/exif.hpp
+++ b/modules/imgcodecs/src/exif.hpp
@@ -51,6 +51,7 @@
 #include <stdint.h>
 #include <string>
 #include <vector>
+#include <iostream>
 
 namespace cv
 {
@@ -131,24 +132,6 @@ struct ExifEntry_t
 };
 
 /**
- * @brief Picture orientation which may be taken from EXIF
- *      Orientation usually matters when the picture is taken by
- *      smartphone or other camera with orientation sensor support
- *      Corresponds to EXIF 2.3 Specification
- */
-enum ImageOrientation
-{
-    IMAGE_ORIENTATION_TL = 1, ///< Horizontal (normal)
-    IMAGE_ORIENTATION_TR = 2, ///< Mirrored horizontal
-    IMAGE_ORIENTATION_BR = 3, ///< Rotate 180
-    IMAGE_ORIENTATION_BL = 4, ///< Mirrored vertical
-    IMAGE_ORIENTATION_LT = 5, ///< Mirrored horizontal & rotate 270 CW
-    IMAGE_ORIENTATION_RT = 6, ///< Rotate 90 CW
-    IMAGE_ORIENTATION_RB = 7, ///< Mirrored horizontal & rotate 90 CW
-    IMAGE_ORIENTATION_LB = 8  ///< Rotate 270 CW
-};
-
-/**
  * @brief Reading exif information from Jpeg file
  *
  * Usage example for getting the orientation of the image:
@@ -168,9 +151,9 @@ public:
     /**
      * @brief ExifReader constructor. Constructs an object of exif reader
      *
-     * @param [in]filename The name of file to look exif info in
+     * @param [in]stream An istream to look for EXIF bytes from
      */
-    explicit ExifReader( std::string filename );
+    explicit ExifReader( std::istream& stream );
     ~ExifReader();
 
 
@@ -190,7 +173,7 @@ public:
     ExifEntry_t getTag( const ExifTagName tag );
 
 private:
-    std::string m_filename;
+    std::istream& m_stream;
     std::vector<unsigned char> m_data;
     std::map<int, ExifEntry_t > m_exif;
     Endianess_t m_format;
@@ -198,7 +181,7 @@ private:
     void parseExif();
     bool checkTagMark() const;
 
-    size_t getFieldSize ( FILE* f ) const;
+    size_t getFieldSize ();
     size_t getNumDirEntry() const;
     uint32_t getStartOffset() const;
     uint16_t getExifTag( const size_t offset ) const;
@@ -247,7 +230,6 @@ private:
 };
 
 
-
 }
 
 #endif /* _OPENCV_EXIF_HPP_ */
diff --git a/modules/imgcodecs/src/grfmt_base.cpp b/modules/imgcodecs/src/grfmt_base.cpp
index cda8b10..d53769d 100644
--- a/modules/imgcodecs/src/grfmt_base.cpp
+++ b/modules/imgcodecs/src/grfmt_base.cpp
@@ -47,6 +47,14 @@
 namespace cv
 {
 
+ImageDecoder::~ImageDecoder()
+{
+}
+
+ImageEncoder::~ImageEncoder()
+{
+}
+
 BaseImageDecoder::BaseImageDecoder()
 {
     m_width = m_height = 0;
@@ -89,9 +97,21 @@ int BaseImageDecoder::setScale( const int& scale_denom )
     return temp;
 }
 
-ImageDecoder BaseImageDecoder::newDecoder() const
+bool BaseImageDecoder::checkDest( const Mat& dst, int dst_type ) const
+{
+    size_t have_size = dst.total() * dst.elemSize();
+    size_t want_size = m_width * m_height * CV_ELEM_SIZE(dst_type);
+    return have_size >= want_size;
+}
+
+String BaseImageDecoder::getDescription() const
+{
+    return m_description;
+}
+
+Ptr<ImageDecoder> BaseImageDecoder::newDecoder() const
 {
-    return ImageDecoder();
+    return Ptr<BaseImageDecoder>();
 }
 
 BaseImageEncoder::BaseImageEncoder()
@@ -126,9 +146,9 @@ bool BaseImageEncoder::setDestination( std::vector<uchar>& buf )
     return true;
 }
 
-ImageEncoder BaseImageEncoder::newEncoder() const
+Ptr<ImageEncoder> BaseImageEncoder::newEncoder() const
 {
-    return ImageEncoder();
+    return Ptr<BaseImageEncoder>();
 }
 
 void BaseImageEncoder::throwOnEror() const
diff --git a/modules/imgcodecs/src/grfmt_base.hpp b/modules/imgcodecs/src/grfmt_base.hpp
index 88e3ca7..e0fd0a9 100644
--- a/modules/imgcodecs/src/grfmt_base.hpp
+++ b/modules/imgcodecs/src/grfmt_base.hpp
@@ -43,19 +43,14 @@
 #ifndef _GRFMT_BASE_H_
 #define _GRFMT_BASE_H_
 
+#include "opencv2/imgcodecs.hpp"
 #include "utils.hpp"
 #include "bitstrm.hpp"
 
 namespace cv
 {
 
-class BaseImageDecoder;
-class BaseImageEncoder;
-typedef Ptr<BaseImageEncoder> ImageEncoder;
-typedef Ptr<BaseImageDecoder> ImageDecoder;
-
-///////////////////////////////// base class for decoders ////////////////////////
-class BaseImageDecoder
+class BaseImageDecoder : public ImageDecoder
 {
 public:
     BaseImageDecoder();
@@ -64,20 +59,22 @@ public:
     int width() const { return m_width; }
     int height() const { return m_height; }
     virtual int type() const { return m_type; }
+    virtual int orientation() const { return IMAGE_ORIENTATION_TL; }
 
     virtual bool setSource( const String& filename );
     virtual bool setSource( const Mat& buf );
     virtual int setScale( const int& scale_denom );
     virtual bool readHeader() = 0;
     virtual bool readData( Mat& img ) = 0;
+    bool checkDest( const Mat& dst, int type ) const;
 
     /// Called after readData to advance to the next page, if any.
     virtual bool nextPage() { return false; }
 
     virtual size_t signatureLength() const;
     virtual bool checkSignature( const String& signature ) const;
-    virtual ImageDecoder newDecoder() const;
-
+    virtual Ptr<ImageDecoder> newDecoder() const;
+    virtual String getDescription() const;
 protected:
     int  m_width;  // width  of the image ( filled by readHeader )
     int  m_height; // height of the image ( filled by readHeader )
@@ -87,15 +84,15 @@ protected:
     String m_signature;
     Mat m_buf;
     bool m_buf_supported;
+    String m_description;
 };
 
-
-///////////////////////////// base class for encoders ////////////////////////////
-class BaseImageEncoder
+class BaseImageEncoder : public ImageEncoder
 {
 public:
     BaseImageEncoder();
     virtual ~BaseImageEncoder() {}
+
     virtual bool isFormatSupported( int depth ) const;
 
     virtual bool setDestination( const String& filename );
@@ -103,10 +100,9 @@ public:
     virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
 
     virtual String getDescription() const;
-    virtual ImageEncoder newEncoder() const;
+    virtual Ptr<ImageEncoder> newEncoder() const;
 
     virtual void throwOnEror() const;
-
 protected:
     String m_description;
 
diff --git a/modules/imgcodecs/src/grfmt_bmp.cpp b/modules/imgcodecs/src/grfmt_bmp.cpp
index 4063d5b..deba0a0 100644
--- a/modules/imgcodecs/src/grfmt_bmp.cpp
+++ b/modules/imgcodecs/src/grfmt_bmp.cpp
@@ -55,6 +55,7 @@ BmpDecoder::BmpDecoder()
     m_signature = fmtSignBmp;
     m_offset = -1;
     m_buf_supported = true;
+    m_description = "BMP";
 }
 
 
@@ -68,7 +69,7 @@ void  BmpDecoder::close()
     m_strm.close();
 }
 
-ImageDecoder BmpDecoder::newDecoder() const
+Ptr<ImageDecoder> BmpDecoder::newDecoder() const
 {
     return makePtr<BmpDecoder>();
 }
@@ -200,6 +201,13 @@ bool  BmpDecoder::readData( Mat& img )
     if( m_offset < 0 || !m_strm.isOpened())
         return false;
 
+    int dst_type = color ? CV_8UC3 : CV_8UC1;
+
+    if( !checkDest( img, dst_type ) )
+    {
+        return false;
+    }
+
     if( m_origin == IPL_ORIGIN_BL )
     {
         data += (m_height - 1)*step;
@@ -499,7 +507,7 @@ BmpEncoder::~BmpEncoder()
 {
 }
 
-ImageEncoder BmpEncoder::newEncoder() const
+Ptr<ImageEncoder> BmpEncoder::newEncoder() const
 {
     return makePtr<BmpEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_bmp.hpp b/modules/imgcodecs/src/grfmt_bmp.hpp
index b4443b7..bed17fc 100644
--- a/modules/imgcodecs/src/grfmt_bmp.hpp
+++ b/modules/imgcodecs/src/grfmt_bmp.hpp
@@ -69,7 +69,7 @@ public:
     bool  readHeader();
     void  close();
 
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
 
@@ -91,7 +91,7 @@ public:
 
     bool  write( const Mat& img, const std::vector<int>& params );
 
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 };
 
 }
diff --git a/modules/imgcodecs/src/grfmt_exr.cpp b/modules/imgcodecs/src/grfmt_exr.cpp
index 71d8912..8df77d6 100644
--- a/modules/imgcodecs/src/grfmt_exr.cpp
+++ b/modules/imgcodecs/src/grfmt_exr.cpp
@@ -81,6 +81,7 @@ ExrDecoder::ExrDecoder()
     m_signature = "\x76\x2f\x31\x01";
     m_file = 0;
     m_red = m_green = m_blue = 0;
+    m_description = "EXR";
 }
 
 
@@ -201,6 +202,14 @@ bool  ExrDecoder::readData( Mat& img )
 
     xstep = m_native_depth ? 4 : 1;
 
+    int dst_width = color ? 3 : 1;
+    int dst_type = CV_MAKE_TYPE( img.depth(), dst_width );
+    if( !checkDest( img, dst_type ) )
+    {
+        close();
+        return false;
+    }
+
     if( !m_native_depth || (!color && m_iscolor ))
     {
         buffer = (char *)new float[ m_width * 3 ];
@@ -554,7 +563,7 @@ void  ExrDecoder::RGBToGray( float *in, float *out )
 }
 
 
-ImageDecoder ExrDecoder::newDecoder() const
+Ptr<ImageDecoder> ExrDecoder::newDecoder() const
 {
     return makePtr<ExrDecoder>();
 }
@@ -729,7 +738,7 @@ bool  ExrEncoder::write( const Mat& img, const std::vector<int>& )
 }
 
 
-ImageEncoder ExrEncoder::newEncoder() const
+Ptr<ImageEncoder> ExrEncoder::newEncoder() const
 {
     return makePtr<ExrEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_exr.hpp b/modules/imgcodecs/src/grfmt_exr.hpp
index 93dfb91..85d3df4 100644
--- a/modules/imgcodecs/src/grfmt_exr.hpp
+++ b/modules/imgcodecs/src/grfmt_exr.hpp
@@ -75,7 +75,7 @@ public:
     bool  readHeader();
     void  close();
 
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
     void  UpSample( uchar *data, int xstep, int ystep, int xsample, int ysample );
@@ -107,7 +107,7 @@ public:
 
     bool  isFormatSupported( int depth ) const;
     bool  write( const Mat& img, const std::vector<int>& params );
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 };
 
 }
diff --git a/modules/imgcodecs/src/grfmt_gdal.cpp b/modules/imgcodecs/src/grfmt_gdal.cpp
index 4bb8dd0..fefb308 100644
--- a/modules/imgcodecs/src/grfmt_gdal.cpp
+++ b/modules/imgcodecs/src/grfmt_gdal.cpp
@@ -175,6 +175,7 @@ GdalDecoder::GdalDecoder(){
 
     m_driver = NULL;
     m_dataset = NULL;
+    m_description = "GDAL";
 }
 
 /**
@@ -553,7 +554,7 @@ void GdalDecoder::close(){
 /**
  * Create a new decoder
 */
-ImageDecoder GdalDecoder::newDecoder()const{
+Ptr<ImageDecoder> GdalDecoder::newDecoder()const{
     return makePtr<GdalDecoder>();
 }
 
diff --git a/modules/imgcodecs/src/grfmt_gdal.hpp b/modules/imgcodecs/src/grfmt_gdal.hpp
index 0273960..f86031f 100644
--- a/modules/imgcodecs/src/grfmt_gdal.hpp
+++ b/modules/imgcodecs/src/grfmt_gdal.hpp
@@ -135,7 +135,7 @@ class GdalDecoder : public BaseImageDecoder{
         /**
          * Create a new decoder
         */
-        ImageDecoder newDecoder() const;
+        Ptr<ImageDecoder> newDecoder() const;
 
         /**
          * Test the file signature
diff --git a/modules/imgcodecs/src/grfmt_gdcm.cpp b/modules/imgcodecs/src/grfmt_gdcm.cpp
index a1d9e9d..2a4e34a 100644
--- a/modules/imgcodecs/src/grfmt_gdcm.cpp
+++ b/modules/imgcodecs/src/grfmt_gdcm.cpp
@@ -68,6 +68,7 @@ DICOMDecoder::DICOMDecoder()
     // DICOM preamble is 128 bytes (can have any value, defaults to 0) + 4 bytes magic number (DICM)
     m_signature = String(preamble_skip, (char)'\x0') + getMagic();
     m_buf_supported = false;
+    m_description = "GDCM";
 }
 
 bool DICOMDecoder::checkSignature( const String& signature ) const
@@ -83,7 +84,7 @@ bool DICOMDecoder::checkSignature( const String& signature ) const
     return false;
 }
 
-ImageDecoder DICOMDecoder::newDecoder() const
+Ptr<ImageDecoder> DICOMDecoder::newDecoder() const
 {
     return makePtr<DICOMDecoder>();
 }
@@ -194,4 +195,4 @@ bool  DICOMDecoder::readData( Mat& csImage )
 
 }
 
-#endif // HAVE_GDCM
\ No newline at end of file
+#endif // HAVE_GDCM
diff --git a/modules/imgcodecs/src/grfmt_gdcm.hpp b/modules/imgcodecs/src/grfmt_gdcm.hpp
index d8dc60f..49b6085 100644
--- a/modules/imgcodecs/src/grfmt_gdcm.hpp
+++ b/modules/imgcodecs/src/grfmt_gdcm.hpp
@@ -59,7 +59,7 @@ public:
     DICOMDecoder();
     bool  readData( Mat& img );
     bool  readHeader();
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
     virtual bool checkSignature( const String& signature ) const;
 };
 
diff --git a/modules/imgcodecs/src/grfmt_hdr.cpp b/modules/imgcodecs/src/grfmt_hdr.cpp
index f795120..1a4fb9b 100644
--- a/modules/imgcodecs/src/grfmt_hdr.cpp
+++ b/modules/imgcodecs/src/grfmt_hdr.cpp
@@ -53,6 +53,7 @@ HdrDecoder::HdrDecoder()
     m_signature_alt = "#?RADIANCE";
     file = NULL;
     m_type = CV_32FC3;
+    m_description = "HDR";
 }
 
 HdrDecoder::~HdrDecoder()
@@ -108,7 +109,7 @@ bool HdrDecoder::checkSignature( const String& signature ) const
     return false;
 }
 
-ImageDecoder HdrDecoder::newDecoder() const
+Ptr<ImageDecoder> HdrDecoder::newDecoder() const
 {
     return makePtr<HdrDecoder>();
 }
@@ -152,7 +153,7 @@ bool HdrEncoder::write( const Mat& input_img, const std::vector<int>& params )
     return true;
 }
 
-ImageEncoder HdrEncoder::newEncoder() const
+Ptr<ImageEncoder> HdrEncoder::newEncoder() const
 {
     return makePtr<HdrEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_hdr.hpp b/modules/imgcodecs/src/grfmt_hdr.hpp
index 3ed8015..077ae4f 100644
--- a/modules/imgcodecs/src/grfmt_hdr.hpp
+++ b/modules/imgcodecs/src/grfmt_hdr.hpp
@@ -63,7 +63,7 @@ public:
     bool readHeader();
     bool readData( Mat& img );
     bool checkSignature( const String& signature ) const;
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
     size_t signatureLength() const;
 protected:
     String m_signature_alt;
@@ -77,7 +77,7 @@ public:
     HdrEncoder();
     ~HdrEncoder();
     bool write( const Mat& img, const std::vector<int>& params );
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
     bool isFormatSupported( int depth ) const;
 protected:
 
@@ -85,4 +85,4 @@ protected:
 
 }
 
-#endif/*_GRFMT_HDR_H_*/
\ No newline at end of file
+#endif/*_GRFMT_HDR_H_*/
diff --git a/modules/imgcodecs/src/grfmt_jpeg.cpp b/modules/imgcodecs/src/grfmt_jpeg.cpp
index 1f5f1e8..6391bfc 100644
--- a/modules/imgcodecs/src/grfmt_jpeg.cpp
+++ b/modules/imgcodecs/src/grfmt_jpeg.cpp
@@ -41,6 +41,8 @@
 
 #include "precomp.hpp"
 #include "grfmt_jpeg.hpp"
+#include "exif.hpp"
+#include <fstream>
 
 #ifdef HAVE_JPEG
 
@@ -75,6 +77,49 @@ extern "C" {
 #include "jpeglib.h"
 }
 
+namespace {
+
+class ByteStreamBuffer : public std::streambuf
+{
+public:
+   ByteStreamBuffer(char* base, size_t length)
+   {
+      setg( base, base, base + length );
+   };
+
+protected:
+   virtual pos_type seekoff( off_type off,
+                             std::ios_base::seekdir dir,
+                             std::ios_base::openmode )
+   {
+      if( off > INT_MAX )
+      {
+         return -1;
+      }
+
+      if( off < INT_MIN )
+      {
+         return -1;
+      }
+
+      if( dir == std::ios_base::cur )
+      {
+         if( gptr() + off >= egptr() )
+         {
+            return -1;
+         }
+         if( gptr() + off < eback() )
+         {
+            return -1;
+         }
+         gbump( static_cast<int>(off) );
+      }
+
+      return gptr() - eback();
+   }
+};
+
+}
 namespace cv
 {
 
@@ -176,7 +221,9 @@ JpegDecoder::JpegDecoder()
     m_signature = "\xFF\xD8\xFF";
     m_state = 0;
     m_f = 0;
+    m_orientation = IMAGE_ORIENTATION_TL;
     m_buf_supported = true;
+    m_description = "JPEG";
 }
 
 
@@ -206,7 +253,7 @@ void  JpegDecoder::close()
     m_type = -1;
 }
 
-ImageDecoder JpegDecoder::newDecoder() const
+Ptr<ImageDecoder> JpegDecoder::newDecoder() const
 {
     return makePtr<JpegDecoder>();
 }
@@ -256,6 +303,37 @@ bool  JpegDecoder::readHeader()
     if( !result )
         close();
 
+    // set a default in case we don't find the tag
+    m_orientation = IMAGE_ORIENTATION_TL;
+    if( !m_buf.empty() )
+    {
+       ByteStreamBuffer bsb( reinterpret_cast<char*>(m_buf.data), m_buf.total() * m_buf.elemSize() );
+       std::istream stream( &bsb );
+       ExifReader reader( stream );
+       if( reader.parse() )
+       {
+           ExifEntry_t entry = reader.getTag( ORIENTATION );
+           if (entry.tag != INVALID_TAG)
+           {
+               m_orientation = int(entry.field_u16); //orientation is unsigned short, so check field_u16
+           }
+       }
+    }
+    else
+    {
+       std::ifstream stream( m_filename.c_str(), std::ios_base::in | std::ios_base::binary );
+       ExifReader reader( stream );
+       if( reader.parse() )
+       {
+           ExifEntry_t entry = reader.getTag( ORIENTATION );
+           if (entry.tag != INVALID_TAG)
+           {
+               m_orientation = int(entry.field_u16); //orientation is unsigned short, so check field_u16
+           }
+       }
+       stream.close();
+    }
+
     return result;
 }
 
@@ -398,8 +476,9 @@ bool  JpegDecoder::readData( Mat& img )
     volatile bool result = false;
     int step = (int)img.step;
     bool color = img.channels() > 1;
+    int dst_type = color ? CV_8UC3 : CV_8UC1;
 
-    if( m_state && m_width && m_height )
+    if( m_state && m_width && m_height && checkDest( img, dst_type ) )
     {
         jpeg_decompress_struct* cinfo = &((JpegState*)m_state)->cinfo;
         JpegErrorMgr* jerr = &((JpegState*)m_state)->jerr;
@@ -542,7 +621,7 @@ JpegEncoder::~JpegEncoder()
 {
 }
 
-ImageEncoder JpegEncoder::newEncoder() const
+Ptr<ImageEncoder> JpegEncoder::newEncoder() const
 {
     return makePtr<JpegEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_jpeg.hpp b/modules/imgcodecs/src/grfmt_jpeg.hpp
index 8455b19..69ca50f 100644
--- a/modules/imgcodecs/src/grfmt_jpeg.hpp
+++ b/modules/imgcodecs/src/grfmt_jpeg.hpp
@@ -60,16 +60,19 @@ public:
     JpegDecoder();
     virtual ~JpegDecoder();
 
+    int orientation() const { return m_orientation; }
+
     bool  readData( Mat& img );
     bool  readHeader();
     void  close();
 
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
 
     FILE* m_f;
     void* m_state;
+    int m_orientation;
 };
 
 
@@ -80,7 +83,7 @@ public:
     virtual ~JpegEncoder();
 
     bool  write( const Mat& img, const std::vector<int>& params );
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 };
 
 }
diff --git a/modules/imgcodecs/src/grfmt_jpeg2000.cpp b/modules/imgcodecs/src/grfmt_jpeg2000.cpp
index 24aa457..0f488e3 100644
--- a/modules/imgcodecs/src/grfmt_jpeg2000.cpp
+++ b/modules/imgcodecs/src/grfmt_jpeg2000.cpp
@@ -80,6 +80,7 @@ Jpeg2KDecoder::Jpeg2KDecoder()
     m_signature = '\0' + String() + '\0' + String() + '\0' + String("\x0cjP  \r\n\x87\n");
     m_stream = 0;
     m_image = 0;
+    m_description = "JPEG2000";
 }
 
 
@@ -87,7 +88,7 @@ Jpeg2KDecoder::~Jpeg2KDecoder()
 {
 }
 
-ImageDecoder Jpeg2KDecoder::newDecoder() const
+Ptr<ImageDecoder> Jpeg2KDecoder::newDecoder() const
 {
     return makePtr<Jpeg2KDecoder>();
 }
@@ -160,6 +161,14 @@ bool  Jpeg2KDecoder::readData( Mat& img )
     jas_stream_t* stream = (jas_stream_t*)m_stream;
     jas_image_t* image = (jas_image_t*)m_image;
 
+    int dst_width = color ? 3 : 1;
+    int dst_type = CV_MAKE_TYPE( img.depth(), dst_width );
+    if( !checkDest( img, dst_type ) )
+    {
+        close();
+        return false;
+    }
+
 #ifndef WIN32
     // At least on some Linux instances the
     // system libjasper segfaults when
@@ -424,7 +433,7 @@ Jpeg2KEncoder::~Jpeg2KEncoder()
 {
 }
 
-ImageEncoder Jpeg2KEncoder::newEncoder() const
+Ptr<ImageEncoder> Jpeg2KEncoder::newEncoder() const
 {
     return makePtr<Jpeg2KEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_jpeg2000.hpp b/modules/imgcodecs/src/grfmt_jpeg2000.hpp
index 0c0954f..1503867 100644
--- a/modules/imgcodecs/src/grfmt_jpeg2000.hpp
+++ b/modules/imgcodecs/src/grfmt_jpeg2000.hpp
@@ -60,7 +60,7 @@ public:
     bool  readData( Mat& img );
     bool  readHeader();
     void  close();
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
     bool  readComponent8u( uchar *data, void *buffer, int step, int cmpt,
@@ -81,7 +81,7 @@ public:
 
     bool  isFormatSupported( int depth ) const;
     bool  write( const Mat& img, const std::vector<int>& params );
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 
 protected:
     bool  writeComponent8u( void *img, const Mat& _img );
diff --git a/modules/imgcodecs/src/grfmt_pam.cpp b/modules/imgcodecs/src/grfmt_pam.cpp
index ac7198a..7d33b2a 100644
--- a/modules/imgcodecs/src/grfmt_pam.cpp
+++ b/modules/imgcodecs/src/grfmt_pam.cpp
@@ -324,6 +324,7 @@ PAMDecoder::PAMDecoder()
     m_buf_supported = true;
     bit_mode = false;
     selected_fmt = CV_IMWRITE_PAM_FORMAT_NULL;
+    m_description = "PAM";
 }
 
 
@@ -344,7 +345,7 @@ bool PAMDecoder::checkSignature( const String& signature ) const
            isspace(signature[2]);
 }
 
-ImageDecoder PAMDecoder::newDecoder() const
+Ptr<ImageDecoder> PAMDecoder::newDecoder() const
 {
     return makePtr<PAMDecoder>();
 }
@@ -486,6 +487,12 @@ bool  PAMDecoder::readData( Mat& img )
     const struct pam_format *fmt = NULL;
     struct channel_layout layout;
 
+    int dst_type = CV_MAKETYPE( img.depth(), target_channels );
+    if( !checkDest( img, dst_type ) )
+    {
+        return false;
+    }
+
     /* setting buffer to max data size so scaling up is possible */
     AutoBuffer<uchar> _src(src_elems_per_row * 2);
     uchar* src = _src;
@@ -631,7 +638,7 @@ PAMEncoder::~PAMEncoder()
 }
 
 
-ImageEncoder PAMEncoder::newEncoder() const
+Ptr<ImageEncoder> PAMEncoder::newEncoder() const
 {
     return makePtr<PAMEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_pam.hpp b/modules/imgcodecs/src/grfmt_pam.hpp
index 8b3b1f1..306f0f3 100644
--- a/modules/imgcodecs/src/grfmt_pam.hpp
+++ b/modules/imgcodecs/src/grfmt_pam.hpp
@@ -71,7 +71,7 @@ public:
 
     size_t signatureLength() const;
     bool checkSignature( const String& signature ) const;
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
 
@@ -91,9 +91,9 @@ public:
     bool  isFormatSupported( int depth ) const;
     bool  write( const Mat& img, const std::vector<int>& params );
 
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 };
 
 }
 
-#endif /* _OPENCV_PAM_HPP_ */
\ No newline at end of file
+#endif /* _OPENCV_PAM_HPP_ */
diff --git a/modules/imgcodecs/src/grfmt_png.cpp b/modules/imgcodecs/src/grfmt_png.cpp
index c8ff244..57a3b76 100644
--- a/modules/imgcodecs/src/grfmt_png.cpp
+++ b/modules/imgcodecs/src/grfmt_png.cpp
@@ -91,6 +91,7 @@ PngDecoder::PngDecoder()
     m_f = 0;
     m_buf_supported = true;
     m_buf_pos = 0;
+    m_description = "PNG";
 }
 
 
@@ -99,7 +100,7 @@ PngDecoder::~PngDecoder()
     close();
 }
 
-ImageDecoder PngDecoder::newDecoder() const
+Ptr<ImageDecoder> PngDecoder::newDecoder() const
 {
     return makePtr<PngDecoder>();
 }
@@ -227,7 +228,19 @@ bool  PngDecoder::readData( Mat& img )
     uchar** buffer = _buffer;
     int color = img.channels() > 1;
 
-    if( m_png_ptr && m_info_ptr && m_end_info && m_width && m_height )
+    int dst_type;
+    if( img.channels() == 1 )
+    {
+        dst_type = CV_MAKETYPE( img.depth(), 1 );
+    } else if( img.channels() == 4 )
+    {
+        dst_type = CV_MAKETYPE( img.depth(), 4 );
+    } else
+    {
+        dst_type = CV_MAKETYPE( img.depth(), 3 );
+    }
+
+    if( m_png_ptr && m_info_ptr && m_end_info && m_width && m_height && checkDest( img, dst_type ) )
     {
         png_structp png_ptr = (png_structp)m_png_ptr;
         png_infop info_ptr = (png_infop)m_info_ptr;
@@ -312,7 +325,7 @@ bool  PngEncoder::isFormatSupported( int depth ) const
     return depth == CV_8U || depth == CV_16U;
 }
 
-ImageEncoder PngEncoder::newEncoder() const
+Ptr<ImageEncoder> PngEncoder::newEncoder() const
 {
     return makePtr<PngEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_png.hpp b/modules/imgcodecs/src/grfmt_png.hpp
index 3a3d004..fdcc038 100644
--- a/modules/imgcodecs/src/grfmt_png.hpp
+++ b/modules/imgcodecs/src/grfmt_png.hpp
@@ -62,7 +62,7 @@ public:
     bool  readHeader();
     void  close();
 
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
 
@@ -87,7 +87,7 @@ public:
     bool  isFormatSupported( int depth ) const;
     bool  write( const Mat& img, const std::vector<int>& params );
 
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 
 protected:
     static void writeDataToBuf(void* png_ptr, uchar* src, size_t size);
diff --git a/modules/imgcodecs/src/grfmt_pxm.cpp b/modules/imgcodecs/src/grfmt_pxm.cpp
index 8afd7b1..6b4acc1 100644
--- a/modules/imgcodecs/src/grfmt_pxm.cpp
+++ b/modules/imgcodecs/src/grfmt_pxm.cpp
@@ -94,6 +94,7 @@ PxMDecoder::PxMDecoder()
 {
     m_offset = -1;
     m_buf_supported = true;
+    m_description = "PXM";
 }
 
 
@@ -114,7 +115,7 @@ bool PxMDecoder::checkSignature( const String& signature ) const
            isspace(signature[2]);
 }
 
-ImageDecoder PxMDecoder::newDecoder() const
+Ptr<ImageDecoder> PxMDecoder::newDecoder() const
 {
     return makePtr<PxMDecoder>();
 }
@@ -198,6 +199,13 @@ bool  PxMDecoder::readData( Mat& img )
     int  width3 = m_width*nch;
     int  i, x, y;
 
+    int dst_width = color ? 3 : 1;
+    int dst_type = CV_MAKE_TYPE( img.depth(), dst_width );
+    if( !checkDest( img, dst_type ) )
+    {
+        return false;
+    }
+
     if( m_offset < 0 || !m_strm.isOpened())
         return false;
 
@@ -354,7 +362,7 @@ PxMEncoder::~PxMEncoder()
 }
 
 
-ImageEncoder  PxMEncoder::newEncoder() const
+Ptr<ImageEncoder>  PxMEncoder::newEncoder() const
 {
     return makePtr<PxMEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_pxm.hpp b/modules/imgcodecs/src/grfmt_pxm.hpp
index 5460e11..60a58f2 100644
--- a/modules/imgcodecs/src/grfmt_pxm.hpp
+++ b/modules/imgcodecs/src/grfmt_pxm.hpp
@@ -62,7 +62,7 @@ public:
 
     size_t signatureLength() const;
     bool checkSignature( const String& signature ) const;
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
 
@@ -84,7 +84,7 @@ public:
     bool  isFormatSupported( int depth ) const;
     bool  write( const Mat& img, const std::vector<int>& params );
 
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 };
 
 }
diff --git a/modules/imgcodecs/src/grfmt_sunras.cpp b/modules/imgcodecs/src/grfmt_sunras.cpp
index 34e5c4e..cf5c0bb 100644
--- a/modules/imgcodecs/src/grfmt_sunras.cpp
+++ b/modules/imgcodecs/src/grfmt_sunras.cpp
@@ -54,6 +54,7 @@ SunRasterDecoder::SunRasterDecoder()
 {
     m_offset = -1;
     m_signature = fmtSignSunRas;
+    m_description = "SUNRAS";
 }
 
 
@@ -61,7 +62,7 @@ SunRasterDecoder::~SunRasterDecoder()
 {
 }
 
-ImageDecoder SunRasterDecoder::newDecoder() const
+Ptr<ImageDecoder> SunRasterDecoder::newDecoder() const
 {
     return makePtr<SunRasterDecoder>();
 }
@@ -164,6 +165,13 @@ bool  SunRasterDecoder::readData( Mat& img )
     int  width3 = m_width*nch;
     int  y;
 
+    int dst_width = color ? 3 : 1;
+    int dst_type = CV_MAKE_TYPE( img.depth(), dst_width );
+    if( !checkDest( img, dst_type ) )
+    {
+        return false;
+    }
+
     if( m_offset < 0 || !m_strm.isOpened())
         return false;
 
@@ -386,7 +394,7 @@ SunRasterEncoder::SunRasterEncoder()
 }
 
 
-ImageEncoder SunRasterEncoder::newEncoder() const
+Ptr<ImageEncoder> SunRasterEncoder::newEncoder() const
 {
     return makePtr<SunRasterEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_sunras.hpp b/modules/imgcodecs/src/grfmt_sunras.hpp
index ef09f9b..cebacb7 100644
--- a/modules/imgcodecs/src/grfmt_sunras.hpp
+++ b/modules/imgcodecs/src/grfmt_sunras.hpp
@@ -75,7 +75,7 @@ public:
     bool  readHeader();
     void  close();
 
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
 
@@ -97,7 +97,7 @@ public:
 
     bool write( const Mat& img, const std::vector<int>& params );
 
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 };
 
 }
diff --git a/modules/imgcodecs/src/grfmt_tiff.cpp b/modules/imgcodecs/src/grfmt_tiff.cpp
index a805274..03f1f73 100644
--- a/modules/imgcodecs/src/grfmt_tiff.cpp
+++ b/modules/imgcodecs/src/grfmt_tiff.cpp
@@ -75,6 +75,7 @@ TiffDecoder::TiffDecoder()
         TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );
     }
     m_hdr = false;
+    m_description = "TIFF";
 }
 
 
@@ -110,7 +111,7 @@ int TiffDecoder::normalizeChannelsNumber(int channels) const
     return channels > 4 ? 4 : channels;
 }
 
-ImageDecoder TiffDecoder::newDecoder() const
+Ptr<ImageDecoder> TiffDecoder::newDecoder() const
 {
     return makePtr<TiffDecoder>();
 }
@@ -222,6 +223,13 @@ bool  TiffDecoder::readData( Mat& img )
         int dst_bpp = (int)(img.elemSize1() * bitsPerByte);
         int wanted_channels = normalizeChannelsNumber(img.channels());
 
+        int dst_type = CV_MAKE_TYPE( img.depth(), wanted_channels );
+        if( !checkDest( img, dst_type ) )
+        {
+            close();
+            return false;
+        }
+
         if(dst_bpp == 8)
         {
             char errmsg[1024];
@@ -483,7 +491,7 @@ TiffEncoder::~TiffEncoder()
 {
 }
 
-ImageEncoder TiffEncoder::newEncoder() const
+Ptr<ImageEncoder> TiffEncoder::newEncoder() const
 {
     return makePtr<TiffEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_tiff.hpp b/modules/imgcodecs/src/grfmt_tiff.hpp
index f019082..2855696 100644
--- a/modules/imgcodecs/src/grfmt_tiff.hpp
+++ b/modules/imgcodecs/src/grfmt_tiff.hpp
@@ -104,7 +104,7 @@ public:
 
     size_t signatureLength() const;
     bool checkSignature( const String& signature ) const;
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
     void* m_tif;
@@ -125,7 +125,7 @@ public:
     bool isFormatSupported( int depth ) const;
 
     bool  write( const Mat& img, const std::vector<int>& params );
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 
 protected:
     void  writeTag( WLByteStream& strm, TiffTag tag,
diff --git a/modules/imgcodecs/src/grfmt_webp.cpp b/modules/imgcodecs/src/grfmt_webp.cpp
index 981ce7b..51a7501 100644
--- a/modules/imgcodecs/src/grfmt_webp.cpp
+++ b/modules/imgcodecs/src/grfmt_webp.cpp
@@ -62,6 +62,7 @@ namespace cv
 WebPDecoder::WebPDecoder()
 {
     m_buf_supported = true;
+    m_description = "WEBP";
 }
 
 WebPDecoder::~WebPDecoder() {}
@@ -88,7 +89,7 @@ bool WebPDecoder::checkSignature(const String & signature) const
     return ret;
 }
 
-ImageDecoder WebPDecoder::newDecoder() const
+Ptr<ImageDecoder> WebPDecoder::newDecoder() const
 {
     return makePtr<WebPDecoder>();
 }
@@ -199,7 +200,7 @@ WebPEncoder::WebPEncoder()
 
 WebPEncoder::~WebPEncoder() { }
 
-ImageEncoder WebPEncoder::newEncoder() const
+Ptr<ImageEncoder> WebPEncoder::newEncoder() const
 {
     return makePtr<WebPEncoder>();
 }
diff --git a/modules/imgcodecs/src/grfmt_webp.hpp b/modules/imgcodecs/src/grfmt_webp.hpp
index ea692bf..7d64c22 100644
--- a/modules/imgcodecs/src/grfmt_webp.hpp
+++ b/modules/imgcodecs/src/grfmt_webp.hpp
@@ -66,7 +66,7 @@ public:
     size_t signatureLength() const;
     bool checkSignature( const String& signature) const;
 
-    ImageDecoder newDecoder() const;
+    Ptr<ImageDecoder> newDecoder() const;
 
 protected:
     Mat data;
@@ -81,7 +81,7 @@ public:
 
     bool write(const Mat& img, const std::vector<int>& params);
 
-    ImageEncoder newEncoder() const;
+    Ptr<ImageEncoder> newEncoder() const;
 };
 
 }
diff --git a/modules/imgcodecs/src/loadsave.cpp b/modules/imgcodecs/src/loadsave.cpp
index 493ccab..bfe5a74 100644
--- a/modules/imgcodecs/src/loadsave.cpp
+++ b/modules/imgcodecs/src/loadsave.cpp
@@ -46,7 +46,6 @@
 #include "precomp.hpp"
 #include "grfmts.hpp"
 #include "utils.hpp"
-#include "exif.hpp"
 #undef min
 #undef max
 #include <iostream>
@@ -115,8 +114,8 @@ struct ImageCodecInitializer
         encoders.push_back( makePtr<PAMEncoder>() );
     }
 
-    std::vector<ImageDecoder> decoders;
-    std::vector<ImageEncoder> encoders;
+    std::vector<Ptr<BaseImageDecoder> > decoders;
+    std::vector<Ptr<BaseImageEncoder> > encoders;
 };
 
 static ImageCodecInitializer codecs;
@@ -128,7 +127,7 @@ static ImageCodecInitializer codecs;
  *
  * @return Image decoder to parse image file.
 */
-static ImageDecoder findDecoder( const String& filename ) {
+Ptr<ImageDecoder> findDecoder( const String& filename ) {
 
     size_t i, maxlen = 0;
 
@@ -144,7 +143,7 @@ static ImageDecoder findDecoder( const String& filename ) {
 
     /// in the event of a failure, return an empty image decoder
     if( !f )
-        return ImageDecoder();
+        return Ptr<BaseImageDecoder>();
 
     // read the file signature
     String signature(maxlen, ' ');
@@ -160,15 +159,15 @@ static ImageDecoder findDecoder( const String& filename ) {
     }
 
     /// If no decoder was found, return base type
-    return ImageDecoder();
+    return Ptr<BaseImageDecoder>();
 }
 
-static ImageDecoder findDecoder( const Mat& buf )
+Ptr<ImageDecoder> findDecoder( const Mat& buf )
 {
     size_t i, maxlen = 0;
 
     if( buf.rows*buf.cols < 1 || !buf.isContinuous() )
-        return ImageDecoder();
+        return Ptr<ImageDecoder>();
 
     for( i = 0; i < codecs.decoders.size(); i++ )
     {
@@ -187,17 +186,17 @@ static ImageDecoder findDecoder( const Mat& buf )
             return codecs.decoders[i]->newDecoder();
     }
 
-    return ImageDecoder();
+    return Ptr<ImageDecoder>();
 }
 
-static ImageEncoder findEncoder( const String& _ext )
+Ptr<ImageEncoder> findEncoder( const String& _ext )
 {
     if( _ext.size() <= 1 )
-        return ImageEncoder();
+        return Ptr<ImageEncoder>();
 
     const char* ext = strrchr( _ext.c_str(), '.' );
     if( !ext )
-        return ImageEncoder();
+        return Ptr<ImageEncoder>();
     int len = 0;
     for( ext++; len < 128 && isalnum(ext[len]); len++ )
         ;
@@ -226,29 +225,14 @@ static ImageEncoder findEncoder( const String& _ext )
         }
     }
 
-    return ImageEncoder();
+    return Ptr<ImageEncoder>();
 }
 
 
 enum { LOAD_CVMAT=0, LOAD_IMAGE=1, LOAD_MAT=2 };
 
-static void ApplyExifOrientation(const String& filename, Mat& img)
+void OrientationTransform(int orientation, Mat& img)
 {
-    int orientation = IMAGE_ORIENTATION_TL;
-
-    if (filename.size() > 0)
-    {
-        ExifReader reader( filename );
-        if( reader.parse() )
-        {
-            ExifEntry_t entry = reader.getTag( ORIENTATION );
-            if (entry.tag != INVALID_TAG)
-            {
-                orientation = entry.field_u16; //orientation is unsigned short, so check field_u16
-            }
-        }
-    }
-
     switch( orientation )
     {
         case    IMAGE_ORIENTATION_TL: //0th row == visual top, 0th column == visual left-hand side
@@ -305,7 +289,7 @@ imread_( const String& filename, int flags, int hdrtype, Mat* mat=0 )
     Mat temp, *data = &temp;
 
     /// Search for the relevant decoder to handle the imagery
-    ImageDecoder decoder;
+    Ptr<ImageDecoder> decoder;
 
 #ifdef HAVE_GDAL
     if(flags != IMREAD_UNCHANGED && (flags & IMREAD_LOAD_GDAL) == IMREAD_LOAD_GDAL ){
@@ -391,6 +375,12 @@ imread_( const String& filename, int flags, int hdrtype, Mat* mat=0 )
         return 0;
     }
 
+    /// optionally rotate the data if EXIF' orientation flag says so
+    if( (flags & IMREAD_IGNORE_ORIENTATION) == 0 && flags != IMREAD_UNCHANGED )
+    {
+        OrientationTransform(decoder->orientation(), *mat);
+    }
+
     if( decoder->setScale( scale_denom ) > 1 ) // if decoder is JpegDecoder then decoder->setScale always returns 1
     {
         resize( *mat, *mat, Size( size.width / scale_denom, size.height / scale_denom ) );
@@ -413,7 +403,7 @@ static bool
 imreadmulti_(const String& filename, int flags, std::vector<Mat>& mats)
 {
     /// Search for the relevant decoder to handle the imagery
-    ImageDecoder decoder;
+    Ptr<ImageDecoder> decoder;
 
 #ifdef HAVE_GDAL
     if (flags != IMREAD_UNCHANGED && (flags & IMREAD_LOAD_GDAL) == IMREAD_LOAD_GDAL){
@@ -461,7 +451,7 @@ imreadmulti_(const String& filename, int flags, std::vector<Mat>& mats)
             // optionally rotate the data if EXIF' orientation flag says so
             if( (flags & IMREAD_IGNORE_ORIENTATION) == 0 && flags != IMREAD_UNCHANGED )
             {
-                ApplyExifOrientation(filename, mat);
+                OrientationTransform(decoder->orientation(), mat);
             }
 
             break;
@@ -493,12 +483,6 @@ Mat imread( const String& filename, int flags )
     /// load the data
     imread_( filename, flags, LOAD_MAT, &img );
 
-    /// optionally rotate the data if EXIF' orientation flag says so
-    if( (flags & IMREAD_IGNORE_ORIENTATION) == 0 && flags != IMREAD_UNCHANGED )
-    {
-        ApplyExifOrientation(filename, img);
-    }
-
     /// return a reference to the data
     return img;
 }
@@ -526,7 +510,7 @@ static bool imwrite_( const String& filename, const Mat& image,
 
     CV_Assert( image.channels() == 1 || image.channels() == 3 || image.channels() == 4 );
 
-    ImageEncoder encoder = findEncoder( filename );
+    Ptr<ImageEncoder> encoder = findEncoder( filename );
     if( !encoder )
         CV_Error( CV_StsError, "could not find a writer for the specified extension" );
     if( !encoder->isFormatSupported(image.depth()) )
@@ -565,7 +549,7 @@ imdecode_( const Mat& buf, int flags, int hdrtype, Mat* mat=0 )
     Mat temp, *data = &temp;
     String filename;
 
-    ImageDecoder decoder = findDecoder(buf);
+    Ptr<ImageDecoder> decoder = findDecoder(buf);
     if( !decoder )
         return 0;
 
@@ -597,6 +581,7 @@ imdecode_( const Mat& buf, int flags, int hdrtype, Mat* mat=0 )
     CvSize size;
     size.width = decoder->width();
     size.height = decoder->height();
+    int orientation = decoder->orientation();
 
     int type = decoder->type();
     if( (flags & IMREAD_LOAD_GDAL) != IMREAD_LOAD_GDAL && flags != IMREAD_UNCHANGED )
@@ -649,6 +634,12 @@ imdecode_( const Mat& buf, int flags, int hdrtype, Mat* mat=0 )
         return 0;
     }
 
+    /// optionally rotate the data if EXIF' orientation flag says so
+    if( (flags & IMREAD_IGNORE_ORIENTATION) == 0 && flags != IMREAD_UNCHANGED )
+    {
+        OrientationTransform(orientation, *mat);
+    }
+
     return hdrtype == LOAD_CVMAT ? (void*)matrix :
         hdrtype == LOAD_IMAGE ? (void*)image : (void*)mat;
 }
@@ -658,6 +649,7 @@ Mat imdecode( InputArray _buf, int flags )
 {
     Mat buf = _buf.getMat(), img;
     imdecode_( buf, flags, LOAD_MAT, &img );
+
     return img;
 }
 
@@ -666,6 +658,7 @@ Mat imdecode( InputArray _buf, int flags, Mat* dst )
     Mat buf = _buf.getMat(), img;
     dst = dst ? dst : &img;
     imdecode_( buf, flags, LOAD_MAT, dst );
+
     return *dst;
 }
 
@@ -677,7 +670,7 @@ bool imencode( const String& ext, InputArray _image,
     int channels = image.channels();
     CV_Assert( channels == 1 || channels == 3 || channels == 4 );
 
-    ImageEncoder encoder = findEncoder( ext );
+    Ptr<ImageEncoder> encoder = findEncoder( ext );
     if( !encoder )
         CV_Error( CV_StsError, "could not find encoder for the specified extension" );
 
@@ -728,13 +721,13 @@ bool imencode( const String& ext, InputArray _image,
 CV_IMPL int
 cvHaveImageReader( const char* filename )
 {
-    cv::ImageDecoder decoder = cv::findDecoder(filename);
+    cv::Ptr<cv::ImageDecoder> decoder = cv::findDecoder(filename);
     return !decoder.empty();
 }
 
 CV_IMPL int cvHaveImageWriter( const char* filename )
 {
-    cv::ImageEncoder encoder = cv::findEncoder(filename);
+    cv::Ptr<cv::ImageEncoder> encoder = cv::findEncoder(filename);
     return !encoder.empty();
 }
 
-- 
2.10.1 (Apple Git-78)

