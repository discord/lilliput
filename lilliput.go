// Package lilliput resizes and encodes images from
// compressed images
package lilliput

import (
	"bytes"
	"errors"
	"strings"
	"time"
)

const (
	// ICCProfileBufferSize is the buffer size for ICC color profile data
	ICCProfileBufferSize = 32768
)

// SRGBICCProfile is the sRGB ICC profile (v4) - used when force_sdr overrides HDR ICC profiles.
// Source: https://github.com/saucecontrol/Compact-ICC-Profiles
var SRGBICCProfile = []byte{
	0x00, 0x00, 0x01, 0xE0, 0x6C, 0x63, 0x6D, 0x73, 0x04, 0x20, 0x00, 0x00, 0x6D, 0x6E, 0x74, 0x72,
	0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5A, 0x20, 0x07, 0xE2, 0x00, 0x03, 0x00, 0x14, 0x00, 0x09,
	0x00, 0x0E, 0x00, 0x1D, 0x61, 0x63, 0x73, 0x70, 0x4D, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,
	0x73, 0x61, 0x77, 0x73, 0x63, 0x74, 0x72, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xD3, 0x2D,
	0x68, 0x61, 0x6E, 0x64, 0x79, 0xE9, 0xBF, 0x56, 0x5A, 0x3E, 0x01, 0xB6, 0x83, 0x23, 0x85, 0x55,
	0x46, 0xF7, 0x4F, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0A, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x24,
	0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x22, 0x77, 0x74, 0x70, 0x74,
	0x00, 0x00, 0x01, 0x44, 0x00, 0x00, 0x00, 0x14, 0x63, 0x68, 0x61, 0x64, 0x00, 0x00, 0x01, 0x58,
	0x00, 0x00, 0x00, 0x2C, 0x72, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x01, 0x84, 0x00, 0x00, 0x00, 0x14,
	0x67, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x01, 0x98, 0x00, 0x00, 0x00, 0x14, 0x62, 0x58, 0x59, 0x5A,
	0x00, 0x00, 0x01, 0xAC, 0x00, 0x00, 0x00, 0x14, 0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xC0,
	0x00, 0x00, 0x00, 0x20, 0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x20,
	0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x20, 0x6D, 0x6C, 0x75, 0x63,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x65, 0x6E, 0x55, 0x53,
	0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x73, 0x00, 0x52, 0x00, 0x47, 0x00, 0x42,
	0x6D, 0x6C, 0x75, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C,
	0x65, 0x6E, 0x55, 0x53, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x43, 0x00, 0x43,
	0x00, 0x30, 0x00, 0x00, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xD3, 0x2D, 0x73, 0x66, 0x33, 0x32, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x0C, 0x3F, 0x00, 0x00, 0x05, 0xDD, 0xFF, 0xFF, 0xF3, 0x26, 0x00, 0x00, 0x07, 0x90,
	0x00, 0x00, 0xFD, 0x92, 0xFF, 0xFF, 0xFB, 0xA1, 0xFF, 0xFF, 0xFD, 0xA2, 0x00, 0x00, 0x03, 0xDC,
	0x00, 0x00, 0xC0, 0x71, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0xA0,
	0x00, 0x00, 0x38, 0xF2, 0x00, 0x00, 0x03, 0x8F, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x62, 0x96, 0x00, 0x00, 0xB7, 0x89, 0x00, 0x00, 0x18, 0xDA, 0x58, 0x59, 0x5A, 0x20,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xA0, 0x00, 0x00, 0x0F, 0x85, 0x00, 0x00, 0xB6, 0xC4,
	0x70, 0x61, 0x72, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x66, 0x69,
	0x00, 0x00, 0xF2, 0xA7, 0x00, 0x00, 0x0D, 0x59, 0x00, 0x00, 0x13, 0xD0, 0x00, 0x00, 0x0A, 0x5B,
}

var (
	ErrInvalidImage     = errors.New("unrecognized image format")
	ErrDecodingFailed   = errors.New("failed to decode image")
	ErrBufTooSmall      = errors.New("buffer too small to hold image")
	ErrFrameBufNoPixels = errors.New("Framebuffer contains no pixels")
	ErrSkipNotSupported = errors.New("skip operation not supported by this decoder")
	ErrEncodeTimeout    = errors.New("encode timed out")

	gif87Magic   = []byte("GIF87a")
	gif89Magic   = []byte("GIF89a")
	webpMagic    = []byte("RIFF")
	webpFormat   = []byte("WEBP")
	mp42Magic    = []byte("ftypmp42")
	mp4IsomMagic = []byte("ftypisom")
	pngMagic     = []byte{0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a}
)

// A Decoder decompresses compressed image data.
type Decoder interface {
	// Header returns basic image metadata from the image.
	// This is done lazily, reading only the first part of the image and not
	// a full decode.
	Header() (*ImageHeader, error)

	// Close releases any resources associated with the Decoder
	Close()

	// Description returns a string description of the image type, such as
	// "PNG"
	Description() string

	// Duration returns the duration of the content. This property is 0 for
	// static images and animated GIFs.
	Duration() time.Duration

	// DecodeTo fully decodes the image pixel data into f. Generally users should
	// prefer instead using the ImageOps object to decode images.
	DecodeTo(f *Framebuffer) error

	// SkipFrame skips a frame if the decoder supports multiple frames
	// and returns io.EOF if the last frame has been reached
	SkipFrame() error

	// IsStreamable indicates whether the content is optimized for streaming. This is true
	// for static images and animated GIFs.
	IsStreamable() bool

	// HasSubtitles indicates whether the content has one or more subtitle tracks.
	HasSubtitles() bool

	// BackgroundColor as BGRA
	BackgroundColor() uint32

	// ICC returns the ICC color profile, if any
	ICC() []byte

	// LoopCount() returns the number of loops in the image
	LoopCount() int

	// VideoCodec returns the video codec name (H264, HEVC, AV1, VP8, VP9, MPEG4, or Unknown)
	VideoCodec() string

	// AudioCodec returns the audio codec name (AAC, MP3, FLAC, Vorbis, Opus, or Unknown)
	AudioCodec() string
}

// An Encoder compresses raw pixel data into a well-known image type.
type Encoder interface {
	// Encode encodes the pixel data in f into the dst provided to NewEncoder. Encode quality
	// options can be passed into opt, such as map[int]int{lilliput.JpegQuality: 80}
	Encode(f *Framebuffer, opt map[int]int) ([]byte, error)

	// Close releases any resources associated with the Encoder
	Close()
}

func isGIF(maybeGIF []byte) bool {
	return bytes.HasPrefix(maybeGIF, gif87Magic) || bytes.HasPrefix(maybeGIF, gif89Magic)
}

func isWebp(maybeWebp []byte) bool {
	if len(maybeWebp) < 12 {
		return false
	}
	return bytes.HasPrefix(maybeWebp, webpMagic) && bytes.Equal(maybeWebp[8:12], webpFormat)
}

func isAvif(maybeAvif []byte) bool {
	if len(maybeAvif) < 12 {
		return false
	}
	return bytes.Equal(maybeAvif[4:8], []byte("ftyp")) && (bytes.Equal(maybeAvif[8:12], []byte("avif")) || bytes.Equal(maybeAvif[8:12], []byte("avis")))
}

func isMP4(maybeMP4 []byte) bool {
	if len(maybeMP4) < 12 {
		return false
	}

	magic := maybeMP4[4:]
	return bytes.HasPrefix(magic, mp42Magic) || bytes.HasPrefix(magic, mp4IsomMagic)
}

// NewDecoder returns a Decoder which can be used to decode
// image data provided in buf with tone mapping enabled.
func NewDecoder(buf []byte) (Decoder, error) {
	return NewDecoderWithOptionalToneMapping(buf, true)
}

// NewDecoderWithOptionalToneMapping returns a Decoder which can be used to decode
// image data provided in buf with tone mapping optionally enabled. If the first few bytes
// of buf do not point to a valid magic string, an error will be returned.
func NewDecoderWithOptionalToneMapping(buf []byte, toneMappingEnabled bool) (Decoder, error) {
	// Check buffer length before accessing it
	if len(buf) == 0 {
		return nil, ErrInvalidImage
	}

	isBufGIF := isGIF(buf)
	if isBufGIF {
		return newGifDecoder(buf)
	}

	isBufWebp := isWebp(buf)
	if isBufWebp {
		return newWebpDecoder(buf)
	}

	isBufAvif := isAvif(buf)
	if isBufAvif {
		return newAvifDecoder(buf, toneMappingEnabled)
	}

	maybeOpenCVDecoder, err := newOpenCVDecoder(buf)
	if err == nil {
		return maybeOpenCVDecoder, nil
	}

	// Try AVCodec decoder as a fallback
	return newAVCodecDecoder(buf)
}

// EncodeConfig provides configuration options for encoders.
// This struct provides a clean extension point for future encoding config
// without changing function signatures.
type EncodeConfig struct {
	// ICCOverride overrides the decoder's ICC profile when set.
	// Used for HDRâ†’SDR conversion to force sRGB output.
	ICCOverride []byte
}

// NewEncoder returns an Encoder which can be used to encode Framebuffer
// into compressed image data. ext should be a string like ".jpeg" or
// ".png". decodedBy is optional and can be the Decoder used to make
// the Framebuffer. dst is where an encoded image will be written.
// config can be nil to use default settings.
func NewEncoder(ext string, decodedBy Decoder, dst []byte, config *EncodeConfig) (Encoder, error) {
	if strings.ToLower(ext) == ".gif" {
		return newGifEncoder(decodedBy, dst, config)
	}

	if strings.ToLower(ext) == ".webp" {
		return newWebpEncoder(decodedBy, dst, config)
	}

	if strings.ToLower(ext) == ".avif" {
		return newAvifEncoder(decodedBy, dst, config)
	}

	if strings.ToLower(ext) == ".mp4" || strings.ToLower(ext) == ".webm" {
		return nil, errors.New("Encoder cannot encode into video types")
	}

	if strings.ToLower(ext) == ".thumbhash" {
		return newThumbhashEncoder(decodedBy, dst, config)
	}

	return newOpenCVEncoder(ext, decodedBy, dst, config)
}
